<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3-Branch Coupled Baker–Schrödinger Visualization</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: #050510;
      color: #f0f0f0;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 12px 14px;
      background: rgba(5, 5, 20, 0.9);
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      max-width: 320px;
      font-size: 13px;
      z-index: 10;
    }
    #ui h1 {
      font-size: 15px;
      margin: 0 0 8px 0;
    }
    #ui h2 {
      font-size: 13px;
      margin: 10px 0 4px 0;
      border-top: 1px solid rgba(255,255,255,0.1);
      padding-top: 6px;
    }
    .row {
      margin-bottom: 6px;
    }
    label {
      display: block;
      margin-bottom: 2px;
    }
    input[type="range"] {
      width: 100%;
    }
    button {
      margin-right: 6px;
      margin-top: 4px;
      padding: 4px 8px;
      font-size: 12px;
      background: #1f1f3a;
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 5px;
      color: #f0f0f0;
      cursor: pointer;
    }
    button:hover {
      background: #2a2a4d;
    }
    #readout {
      font-family: "SF Mono", Menlo, Consolas, monospace;
      font-size: 11px;
      margin-top: 4px;
      white-space: pre;
    }
  </style>
</head>
<body>
<div id="ui">
  <h1>3-Branch Coupled Baker–Schrödinger</h1>
  <div class="row">
    This toy model integrates a 3-branch coupled Schrödinger equation:<br/>
    <code>i dψᵢ/dt = Eᵢ ψᵢ + ε Σⱼ≠ᵢ Cᵢⱼ ψⱼ</code>
  </div>

  <h2>Parameters</h2>
  <div class="row">
    <label for="coupling">Coupling strength ε: <span id="couplingVal"></span></label>
    <input id="coupling" type="range" min="0" max="1" step="0.01" value="0.3">
  </div>
  <div class="row">
    <label for="spread">Energy spread ΔE: <span id="spreadVal"></span></label>
    <input id="spread" type="range" min="0" max="2" step="0.02" value="1.0">
  </div>
  <div class="row">
    <label for="speed">Simulation speed: <span id="speedVal"></span></label>
    <input id="speed" type="range" min="0.2" max="3" step="0.1" value="1.0">
  </div>

  <h2>Controls</h2>
  <div class="row">
    <button id="playPause">Pause</button>
    <button id="reset">Reset</button>
    <button id="randomize">Randomize phases</button>
  </div>

  <h2>State</h2>
  <div id="readout"></div>
</div>

<!-- Three.js CDN -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

<script>
// =========================
// 1. Quantum model
// =========================

// Complex helper
function Complex(re, im) {
  this.re = re;
  this.im = im;
}
Complex.prototype.clone = function() {
  return new Complex(this.re, this.im);
};
Complex.prototype.abs2 = function() {
  return this.re*this.re + this.im*this.im;
};
Complex.prototype.phase = function() {
  return Math.atan2(this.im, this.re);
};

// 3-branch state
let psi = [
  new Complex(1, 0),
  new Complex(0, 0),
  new Complex(0, 0)
];

// Parameters
let baseEnergy = 0.0;
let energySpread = 1.0; // ΔE
let energies = [0, 0, 0]; // will update from spread
let epsilon = 0.3;        // coupling strength (slider)
let simSpeed = 1.0;       // speed factor
const C = [
  [0, 1, 1],
  [1, 0, 1],
  [1, 1, 0]
];

// Normalize |psi|² = 1
function renormalize() {
  let norm2 = 0;
  for (let i = 0; i < 3; i++) norm2 += psi[i].abs2();
  const inv = 1 / Math.sqrt(norm2 || 1);
  for (let i = 0; i < 3; i++) {
    psi[i].re *= inv;
    psi[i].im *= inv;
  }
}

// Update energies based on spread
function updateEnergies() {
  // simple symmetric: [-ΔE, 0, +ΔE]
  energies[0] = baseEnergy - energySpread;
  energies[1] = baseEnergy;
  energies[2] = baseEnergy + energySpread;
}

// Schrödinger step: Euler integrator (toy)
function stepSchrodinger(dt) {
  const newPsi = [new Complex(0,0), new Complex(0,0), new Complex(0,0)];

  for (let i = 0; i < 3; i++) {
    // Hψ term: E_i ψ_i + ε Σ_j C_ij ψ_j
    let H_re = energies[i] * psi[i].re;
    let H_im = energies[i] * psi[i].im;

    for (let j = 0; j < 3; j++) {
      if (j === i) continue;
      const c = epsilon * C[i][j];
      H_re += c * psi[j].re;
      H_im += c * psi[j].im;
    }

    // dψ/dt = -i * Hψ
    // If Hψ = a + ib, then -i(a+ib) = b - i a
    const dpsi_re = H_im;
    const dpsi_im = -H_re;

    newPsi[i].re = psi[i].re + dpsi_re * dt;
    newPsi[i].im = psi[i].im + dpsi_im * dt;
  }

  psi = newPsi;
  renormalize();
}

// Compute simple “coherence” = average pairwise |ψ_i ψ*_j|
function computeCoherence() {
  let sum = 0;
  let count = 0;
  for (let i = 0; i < 3; i++) {
    for (let j = i+1; j < 3; j++) {
      // overlap magnitude ~ |ψ_i ψ*_j|
      const ov_re = psi[i].re * psi[j].re + psi[i].im * psi[j].im;
      const ov_im = psi[i].im * psi[j].re - psi[i].re * psi[j].im;
      const mag = Math.sqrt(ov_re*ov_re + ov_im*ov_im);
      sum += mag;
      count++;
    }
  }
  return count > 0 ? sum / count : 0;
}

// Randomize phases, keep probabilities fixed
function randomizePhases() {
  for (let i = 0; i < 3; i++) {
    const amp = Math.sqrt(psi[i].abs2());
    const theta = Math.random() * 2 * Math.PI;
    psi[i].re = amp * Math.cos(theta);
    psi[i].im = amp * Math.sin(theta);
  }
}

// =========================
// 2. Three.js scene setup
// =========================

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x050510);

const camera = new THREE.PerspectiveCamera(
  45,
  window.innerWidth / window.innerHeight,
  0.1,
  100
);
camera.position.set(0, 3, 8);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// Lights
const hemiLight = new THREE.HemisphereLight(0x8899ff, 0x111111, 0.8);
scene.add(hemiLight);

const pointLight = new THREE.PointLight(0xffffff, 1.0, 50);
pointLight.position.set(0, 4, 4);
scene.add(pointLight);

// Axes-like floor line
const gridGeom = new THREE.BufferGeometry().setFromPoints([
  new THREE.Vector3(-5, 0, 0),
  new THREE.Vector3(5, 0, 0)
]);
const gridMat = new THREE.LineDashedMaterial({
  color: 0x444466,
  dashSize: 0.2,
  gapSize: 0.1
});
const gridLine = new THREE.Line(gridGeom, gridMat);
gridLine.computeLineDistances();
scene.add(gridLine);

// Branch spheres
const branchSpheres = [];
const branchGroup = new THREE.Group();
scene.add(branchGroup);

for (let i = 0; i < 3; i++) {
  const geom = new THREE.SphereGeometry(0.25, 32, 32);
  const mat = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    emissive: 0x000000,
    roughness: 0.25,
    metalness: 0.1
  });
  const mesh = new THREE.Mesh(geom, mat);
  mesh.position.x = (i - 1) * 2.0; // -2, 0, 2
  branchGroup.add(mesh);
  branchSpheres.push(mesh);
}

// Connecting lines between branches (3 pairs)
const linePairs = [];
const lineMatBase = new THREE.LineBasicMaterial({ color: 0x88ccff });
const indicesPairs = [[0,1],[1,2],[0,2]];

indicesPairs.forEach(() => {
  const geom = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(), new THREE.Vector3()
  ]);
  const mat = lineMatBase.clone();
  const line = new THREE.Line(geom, mat);
  scene.add(line);
  linePairs.push(line);
});

// =========================
// 3. UI bindings
// =========================

const couplingSlider = document.getElementById("coupling");
const couplingVal = document.getElementById("couplingVal");
const spreadSlider = document.getElementById("spread");
const spreadVal = document.getElementById("spreadVal");
const speedSlider = document.getElementById("speed");
const speedVal = document.getElementById("speedVal");
const playPauseBtn = document.getElementById("playPause");
const resetBtn = document.getElementById("reset");
const randomBtn = document.getElementById("randomize");
const readout = document.getElementById("readout");

function updateUIValues() {
  couplingVal.textContent = epsilon.toFixed(2);
  spreadVal.textContent = energySpread.toFixed(2);
  speedVal.textContent = simSpeed.toFixed(2);
}

couplingSlider.addEventListener("input", () => {
  epsilon = parseFloat(couplingSlider.value);
  updateUIValues();
});

spreadSlider.addEventListener("input", () => {
  energySpread = parseFloat(spreadSlider.value);
  updateEnergies();
  updateUIValues();
});

speedSlider.addEventListener("input", () => {
  simSpeed = parseFloat(speedSlider.value);
  updateUIValues();
});

let isRunning = true;

playPauseBtn.addEventListener("click", () => {
  isRunning = !isRunning;
  playPauseBtn.textContent = isRunning ? "Pause" : "Play";
});

resetBtn.addEventListener("click", () => {
  psi = [
    new Complex(1, 0),
    new Complex(0, 0),
    new Complex(0, 0)
  ];
  renormalize();
});

randomBtn.addEventListener("click", () => {
  randomizePhases();
});

updateEnergies();
updateUIValues();

// =========================
// 4. Animation loop
// =========================

let lastTime = performance.now();

function animate(now) {
  requestAnimationFrame(animate);

  const dtRaw = (now - lastTime) / 1000; // seconds
  lastTime = now;
  const dt = dtRaw * simSpeed;

  if (isRunning) {
    // integrate with a small internal dt for stability
    const subSteps = 4;
    const h = dt / subSteps;
    for (let k = 0; k < subSteps; k++) {
      stepSchrodinger(h);
    }
  }

  updateVisualization();
  controls.update();
  renderer.render(scene, camera);
}

function phaseToColor(phase) {
  // Map phase [-π, π] to hue [0, 1]
  const hue = (phase / (2 * Math.PI)) + 0.5;
  const h = (hue % 1 + 1) % 1;
  const s = 1.0;
  const l = 0.5;
  // HSL to RGB
  const c = (1 - Math.abs(2*l - 1)) * s;
  const x = c * (1 - Math.abs((h * 6) % 2 - 1));
  const m = l - c/2;
  let r1, g1, b1;
  if (h < 1/6) { r1 = c; g1 = x; b1 = 0; }
  else if (h < 2/6) { r1 = x; g1 = c; b1 = 0; }
  else if (h < 3/6) { r1 = 0; g1 = c; b1 = x; }
  else if (h < 4/6) { r1 = 0; g1 = x; b1 = c; }
  else if (h < 5/6) { r1 = x; g1 = 0; b1 = c; }
  else { r1 = c; g1 = 0; b1 = x; }
  const r = (r1 + m);
  const g = (g1 + m);
  const b = (b1 + m);
  return new THREE.Color(r, g, b);
}

function updateVisualization() {
  const ampScale = 2.0; // how tall spheres move with probability

  // Update spheres
  for (let i = 0; i < 3; i++) {
    const amp2 = psi[i].abs2();
    const phase = psi[i].phase();
    const y = (amp2 - 1/3) * ampScale; // center around zero

    const sphere = branchSpheres[i];
    sphere.position.y = y;

    const col = phaseToColor(phase);
    sphere.material.color.copy(col);
    sphere.material.emissive.copy(col.clone().multiplyScalar(0.4));
  }

  // Update lines between spheres
  const coherence = computeCoherence();
  for (let p = 0; p < linePairs.length; p++) {
    const [i, j] = indicesPairs[p];
    const line = linePairs[p];
    const positions = line.geometry.attributes.position.array;
    const a = branchSpheres[i].position;
    const b = branchSpheres[j].position;
    positions[0] = a.x; positions[1] = a.y; positions[2] = a.z;
    positions[3] = b.x; positions[4] = b.y; positions[5] = b.z;
    line.geometry.attributes.position.needsUpdate = true;

    // line opacity & color scale with instantaneous overlap magnitude
    const ov_re = psi[i].re * psi[j].re + psi[i].im * psi[j].im;
    const ov_im = psi[i].im * psi[j].re - psi[i].re * psi[j].im;
    const mag = Math.sqrt(ov_re*ov_re + ov_im*ov_im);

    const intensity = Math.min(1, mag * 4);
    line.material.color.setRGB(0.3 + 0.7*intensity, 0.8*intensity, 1.0);
    line.material.opacity = 0.2 + 0.6*intensity;
    line.material.transparent = true;
  }

  // Update readout
  const p1 = psi[0].abs2();
  const p2 = psi[1].abs2();
  const p3 = psi[2].abs2();
  const sumP = (p1 + p2 + p3);
  const coh = coherence;

  readout.textContent =
    `|ψ₁|² = ${p1.toFixed(3)}\n` +
    `|ψ₂|² = ${p2.toFixed(3)}\n` +
    `|ψ₃|² = ${p3.toFixed(3)}\n` +
    `Σ|ψᵢ|² = ${sumP.toFixed(3)} (norm)\n` +
    `Avg pairwise overlap ≈ ${coh.toFixed(3)}\n` +
    `ε = ${epsilon.toFixed(2)},  ΔE = ${energySpread.toFixed(2)}`;
}

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

animate(performance.now());
</script>
</body>
</html>